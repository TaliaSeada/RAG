Revolutionizing Project Management with AI Agents and LangGraph · Published in Towards AI 13 min read · Oct 10, 2024 Listen Share Being A Project Manager Sucks, But Why: Why Does It Suck To Be A Project Manager? (It Doesn’t Have To Be That Way AI-driven project management system RAG LangGraph Project Management Problems Information Overload Inefficient Task Creation Inefficient Task Creation Team Coordination AI Solution Automatically generates and prioritizes tasks Enhances team collaboration Adapts workflows on the fly Gives you practical insights 1. TaskAgent: Automating Task Creation The Struggle with Manual Task Creation Brainstorming Estimating Skill Matching The TaskAgent Solution TaskAgent Leveraging AI Utilizing Historical Data Incorporating Team Skills How It Works Input Input Data Retrieval Retriever AI Generation Output Walkthrough TaskAgent class TaskAgent: """Automates task creation using AI and historical data.""" def __init__(self, retriever: Retriever): self.llm = ChatGroq( groq_api_key=os.getenv("GROQ_API_KEY"), model="mixtral-8x7b-32768", temperature=0, max_tokens=None, timeout=None, max_retries=2, ) self.parser = PydanticOutputParser(pydantic_object=TaskOutput) self.retriever = retriever def create_task(self, description: str, project_id: int) -> dict: # Step 1: Retrieve similar tasks and project context similar_tasks = self.retriever.get_similar_tasks(description, project_id) project_context = self.retriever.get_project_context(project_id) team_skills = self.retriever.get_team_skills(project_id) # Step 2: Prepare the prompt for the AI model prompt = f""" You are a task creation assistant. Create a task based on the following description: '{description}'. Consider these similar tasks: {similar_tasks}. Project context: {project_context}. Available team skills: {team_skills}. Provide a title, estimated duration in hours, and required skills. """ # Step 3: Generate the task using the AI model response = self.llm.generate_text(prompt) task_info = self.parser.parse(response) # Step 4: Return the task details return { 'title': task_info.title, 'description': description, 'estimated_duration': task_info.estimated_duration, 'required_skills': task_info.required_skills, 'created_at': datetime.datetime.now().isoformat(), 'status': 'New', 'project_id': project_id} Some key points to keep in mind AI Model Initialization ChatGroq Prompt Engineering Parsing the Response PydanticOutputParser An Example from Real Life Using the TaskAgent # Initialize the retriever and TaskAgent retriever = Retriever(db_session) task_agent = TaskAgent(retriever) # Create a new task new_task = task_agent.create_task("Implement payment gateway integration", project_id=1) Expected Output { "title": "Develop Payment Gateway Integration", "description": "Implement payment gateway integration", "estimated_duration": 40, "required_skills": ["Python", "Django", "Payment APIs"], "created_at": "2024-10-10T15:30:00", "status": "New", "project_id": 1 } Impact Saves Time Improves Accuracy 2. PriorityAgent: Intelligent Task Prioritization The Challenge of Prioritization Critical Tasks Being Overlooked Inefficient Use of Resources The PriorityAgent Solution PriorityAgent Analyzing Task Complexity Evaluating Project Context Evaluating Project Context Leveraging AI How It Works Input Data Retrieval AI Evaluation Output Walkthrough class PriorityAgent: """Assigns priorities to tasks using AI and project context.""" def __init__(self, retriever: Retriever): self.llm = ChatGroq(...) self.parser = PydanticOutputParser(pydantic_object=PriorityOutput) self.retriever = retriever def assign_priority(self, task: dict) -> dict: # Step 1: Retrieve context project_context = self.retriever.get_project_context(task['project_id']) similar_priorities = self.retriever.get_similar_tasks_priorities(task['description'], task['project_id']) team_skills = self.retriever.get_team_skills(task['project_id']) # Step 2: Prepare the prompt prompt = f""" You are a task prioritization assistant. Assign a priority to the following task: '{task['title']}'. Task details: Duration - {task['estimated_duration']} hours, Skills - {', '.join(task['required_skills'])}. Project context: {project_context}. Similar tasks' priorities: {similar_priorities}. Team skills: {team_skills}. Provide the priority (High, Medium, or Low) and reasoning. """ # Step 3: Get the AI's response response = self.llm.generate_text(prompt) priority_info = self.parser.parse(response) # Step 4: Return the priority details return priority_info.dict() Important things to note Contextual Analysis AI Reasoning An Example from Real Life new_task # Initialize the PriorityAgent priority_agent = PriorityAgent(retriever) # Assign priority to the new task priority_info = priority_agent.assign_priority(new_task) Expected Output { "priority": "High", "reasoning": "The payment gateway is critical for processing transactions, which is essential for the e-commerce platform's functionality." } Impact: Objective Decision-Making Clear Communication 3. SuggestionAgent: Providing Actionable Suggestions The Need for Guidance The SuggestionAgent Solution SuggestionAgent Analyzing Similar Tasks Recommending Resources Providing Step-by-Step Guidance How It Works Input Data Retrieval AI Generation Output Walkthrough class SuggestionAgent: """Generates suggestions and resources for tasks.""" def __init__(self, retriever: Retriever): self.llm = ChatGroq(...) self.parser = PydanticOutputParser(pydantic_object=SuggestionOutput) self.retriever = retriever def generate_suggestions(self, task: Dict[str, Any], project_id: int) -> Dict[str, Any]: # Step 1: Retrieve context project_context = self.retriever.get_project_context(project_id) similar_tasks = self.retriever.get_similar_completed_tasks(task['description'], project_id) team_skills = self.retriever.get_team_skills(project_id) # Step 2: Prepare the prompt prompt = f""" You are a project management assistant. Provide suggestions for the following task: '{task['title']}'. Task details: Duration - {task['estimated_duration']} hours, Skills - {', '.join(task['required_skills'])}. Project context: {project_context}. Similar completed tasks: {similar_tasks}. Team skills: {team_skills}. Provide actionable steps and recommend resources. """ # Step 3: Generate suggestions response = self.llm.generate_text(prompt) suggestions = self.parser.parse(response) # Step 4: Return suggestions return suggestions.dict() An Example from Real Life # Initialize the SuggestionAgent suggestion_agent = SuggestionAgent(retriever) # Generate suggestions for the new task suggestions = suggestion_agent.generate_suggestions(new_task, project_id=1) Expected Output: { "steps": [ "Research payment gateway options (e.g., Stripe, PayPal).", "Set up developer accounts with the chosen gateway.", "Integrate the gateway API into the Django application.", "Implement secure payment processing and data handling.", "Test transactions in a sandbox environment." ], "resources": [ "Stripe API Documentation", "Django Payments Library", "PCI Compliance Guidelines" ] } Impact: Assists Team Members Improves Efficiency 4. CollaborationAgent: Optimizing Team Formation The Challenge of Team Assignment Skill Matching Availability Team Dynamics The CollaborationAgent Solution CollaborationAgent Analyzing Team Members Suggesting Optimal Assignments Proposing Communication Plans How It Works Input Data Retrieval AI Analysis Output Walkthrough class CollaborationAgent: """Suggests team formation and communication plans for tasks.""" def __init__(self, retriever: Retriever): self.llm = ChatGroq(...) self.parser = PydanticOutputParser(pydantic_object=CollaborationOutput) self.retriever = retriever def suggest_collaboration(self, task: Dict[str, Any], project_id: int) -> Dict[str, Any]: # Step 1: Retrieve data available_team_members = self.retriever.get_available_team_members(project_id) project_context = self.retriever.get_project_context(project_id) similar_collaborations = self.retriever.get_similar_collaborations(task['description'], project_id) # Step 2: Prepare the prompt prompt = f""" You are a collaboration assistant. Suggest team members for the following task: '{task['title']}'. Task details: Duration - {task['estimated_duration']} hours, Skills - {', '.join(task['required_skills'])}. Available team members: {available_team_members}. Project context: {project_context}. Similar collaborations: {similar_collaborations}. Provide a team formation and communication plan. """ # Step 3: Generate suggestions response = self.llm.generate_text(prompt) collaboration_info = self.parser.parse(response) # Step 4: Return collaboration details return collaboration_info.dict() An Example from Real Life # Initialize the CollaborationAgent collaboration_agent = CollaborationAgent(retriever) # Suggest collaboration for the new task collaboration_info = collaboration_agent.suggest_collaboration(new_task, project_id=1) Expected Output { "team_formation": [ {"member_name": "Alice Smith", "role": "Lead Developer"}, {"member_name": "Bob Johnson", "role": "Backend Developer"}, {"member_name": "Carol Martinez", "role": "QA Specialist"} ], "communication_plan": "Daily stand-up meetings and a dedicated Slack channel." } Impact: Optimizes Resource Allocation Enhances Team Dynamics Enhances Team Dynamics 5. ReportAgent: Generating Reports The Importance of Reporting Stakeholder Communication Identifying Risks Strategic Planning The ReportAgent Solution ReportAgent Compiling Project Data Analyzing Metrics Providing How It Works Input Data Retrieval AI Generation Output Walkthrough class ReportAgent: """Generates comprehensive project reports using AI.""" def __init__(self, retriever: Retriever): self.llm = ChatGroq(...) self.parser = PydanticOutputParser(pydantic_object=ReportOutput) self.retriever = retriever def generate_report(self, tasks: List[Dict[str, Any]]) -> Dict[str, Any]: if not tasks: return { "summary": "No tasks available for report generation.", "key_metrics": {}, "risks": ["No tasks to analyze risks."], "recommendations": ["t by adding tasks to the project."] } # Step 1: Retrieve context project_id = tasks[0]['project_id'] project_context = self.retriever.get_project_context(project_id) similar_projects = self.retriever.get_similar_projects(project_id) # Step 2: Prepare the prompt prompt = f""" You are an AI assistant generating a project report. Project context: {project_context}. Tasks: {tasks}. Similar projects: {similar_projects}. Provide a summary, key metrics, risks, and recommendations. """ # Step 3: Generate the report response = self.llm.generate_text(prompt) report_info = self.parser.parse(response) # Step 4: Return the report return report_info.dict() An Example from Real Life # Initialize the ReportAgent report_agent = ReportAgent(retriever) # Generate a report for the tasks report = report_agent.generate_report([new_task]) Expected Output { "summary": "The project 'E-Commerce Website Development' is progressing well with the addition of the 'Develop Payment Gateway Integr ation' task.", "key_metrics": { "total_tasks": 15, "completed_tasks": 10, "pending_tasks": 5, "high_priority_tasks": 2 }, "risks": [ "Potential delays due to third-party API dependencies.", "Team members' workload may increase during integration testing." ], "recommendations": [ "Begin integration as early as possible to account for unexpected issues.", "Consider allocating additional resources to high-priority tasks." ] } Impact: Keeps Everyone Updated Proactive Risk Management Informs Strategic Decisions 6. The Retriever Class: Data Retrieval Data Retrieval Retriever Key Functions of the Retriever get_similar_tasks get_project_context get_team_skills get_available_team_members get_similar_completed_tasks get_similar_projects Walkthrough Retriever retriever.py from typing import List, Dict, Any from sqlalchemy.orm import Session from backend.ai_engine.rag.vector_store import vector_store from backend.database import crud from backend.database import models import json class Retriever: def __init__(self, db: Session): self.db = db def get_similar_tasks(self, description: str, project_id: int, k: int = 3) -> List[Dict[str, Any]]: query = f"Project ID: {project_id} | Task: {description}" similar_docs = vector_store.similarity_search(query, k=k) return [{"title": doc.metadata["title"], "description": doc.page_content} for doc in similar_docs] def get_project_context(self, project_id: int) -> Dict[str, Any]: project = crud.get_project(self.db, project_id) if not project: print(f"No project found for id: {project_id}") return {} context = { "name": project.name, "description": project.description, "start_date": str(project.start_date), "end_date": str(project.end_date), "status": project.status, "team_members": [member.name for member in project.team_members] } print(f"Project context: {context}") return context def get_project_team_members(self, project_id: int): return self.db.query(models.TeamMember).join(models.Project.team_members).filter(models.Project.id == project_id).all() def get_similar_tasks_priorities(self, description: str, project_id: int, k: int = 3) -> List[Dict[str, Any]]: query = f"Project ID: {project_id} | Task: {description}" similar_docs = vector_store.similarity_search(query, k=k) return [{"title": doc.metadata["title"], "priority": doc.metadata.get("priority", "Unknown")} for doc in similar_docs] def get_available_team_members(self, project_id: int) -> List[Dict[str, Any]]: team_members = crud.get_project_team_members(self.db, project_id) return [{"name": tm.name, "skills": tm.skills, "role": tm.role} for tm in team_members] def get_similar_collaborations(self, task_description: str, project_id: int, k: int = 3) -> List[Dict[str, Any]]: query = f"Project ID: {project_id} | Collaboration for: {task_description}" similar_docs = vector_store.similarity_search(query, k=k) return [{"task": doc.metadata["task"], "collaboration": doc.page_content} for doc in similar_docs] def get_project_tasks(self, project_id: int) -> List[Dict[str, Any]]: tasks = crud.get_project_tasks(self.db, project_id) return [{"title": task.title, "status": task.status, "priority": task.priority} for task in tasks] def get_team_performance(self, project_id: int) -> Dict[str, Any]: tasks = crud.get_project_tasks(self.db, project_id) completed_tasks = sum(1 for task in tasks if task.status == "Completed") total_tasks = len(tasks) return { "task_completion_rate": completed_tasks / total_tasks if total_tasks > 0 else 0, "total_tasks": total_tasks, "completed_tasks": completed_tasks } def get_similar_projects(self, project_id: int, k: int = 3) -> List[Dict[str, Any]]: project = crud.get_project(self.db, project_id) if not project: return [] query = f"Project: {project.name} | Description: {project.description}" similar_docs = vector_store.similarity_search(query, k=k) return [ { "name": doc.metadata.get("name", "Unnamed Project"), "description": doc.page_content } for doc in similar_docs for doc in similar_docs ] def get_similar_completed_tasks(self, task_description: str, project_id: int, k: int = 3) -> List[Dict[str, Any]]: query = f"Project ID: {project_id} | Completed Task: {task_description}" similar_docs = vector_store.similarity_search(query, k=k) return [{"title": doc.metadata["title"], "description": doc.page_content} for doc in similar_docs] def get_team_skills(self, project_id: int) -> Dict[str, List[str]]: team_members = self.get_project_team_members(project_id) return {tm.name: json.loads(tm.skills) if tm.skills else [] for tm in team_members} def get_available_team_members(self, project_id: int) -> List[Dict[str, Any]]: team_members = crud.get_project_team_members(self.db, project_id) return [{"name": tm.name, "skills": tm.skills.split(',')} for tm in team_members] def get_related_information(self, question: str, k: int = 3) -> List[Dict[str, Any]]: similar_docs = vector_store.similarity_search(question, k=k) related_info = [{"title": doc.metadata.get("title", "Unknown"), "content": doc.page_content} for doc in similar_docs] print(f"Related information: {related_info}") return related_info So, here’s how it works: Similarity Search Database Interaction Data Formatting 7. Orchestrating the Workflow with LangGraph The Need for Dynamic Workflows Real-Time Adjustments State Management LangGraph Solution LangGraph Workflow Definition def create_workflow(): try: workflow = StateGraph(Dict) # Initialize agents task_agent = TaskAgent(retriever) priority_agent = PriorityAgent(retriever) suggestion_agent = SuggestionAgent(retriever) collaboration_agent = CollaborationAgent(retriever) report_agent = ReportAgent(retriever) # Define nodes workflow.add_node("create_task", lambda state: create_task_node(state, task_agent)) workflow.add_node("assign_priority", lambda state: assign_priority_node(state, priority_agent)) workflow.add_node("generate_suggestions", lambda state: generate_suggestions_node(state, suggestion_agent)) workflow.add_node("suggest_collaboration", lambda state: suggest_collaboration_node(state, collaboration_agent)) workflow.add_node("generate_report", lambda state: generate_report_node(state, report_agent)) # Define edges workflow.add_edge("create_task", "assign_priority") workflow.add_edge("assign_priority", "generate_suggestions") workflow.add_edge("generate_suggestions", "suggest_collaboration") workflow.add_edge("suggest_collaboration", "generate_report") workflow.add_edge("generate_report", END) workflow.set_entry_point("create_task") return workflow.compile() except Exception as e: print(f"Error creating workflow: {e}") return None workflow = create_workflow() Node Functions def create_task_node(state: Dict[str, Any], task_agent: TaskAgent) -> Dict[str, Any]: new_task = task_agent.create_task(state['input_description'], state['project_id']) state['tasks'].append(new_task) return state def assign_priority_node(state: Dict[str, Any], priority_agent: PriorityAgent) -> Dict[str, Any]: for task in state['tasks']: priority_info = priority_agent.assign_priority(task) task.update(priority_info) return state def generate_suggestions_node(state: Dict[str, Any], suggestion_agent: SuggestionAgent) -> Dict[str, Any]: for task in state['tasks']: task['suggestions'] = suggestion_agent.generate_suggestions(task, state['project_id']) return state def suggest_collaboration_node(state: Dict[str, Any], collaboration_agent: CollaborationAgent) -> Dict[str, Any]: for task in state['tasks']: task['collaboration'] = collaboration_agent.suggest_collaboration(task, state['project_id']) return state def generate_report_node(state: Dict[str, Any], report_agent: ReportAgent) -> Dict[str, Any]: state['report'] = report_agent.generate_report(state['tasks']) return state Workflow Execution # Define initial state state = { 'input_description': "Implement payment gateway integration", 'project_id': 1, 'tasks': [] } # Execute the workflow workflow(state) Here’s what happens: State Updated state Flexible Workflow Real-World Impact Efficiency Boost Enhanced Collaboration Improved Decision-Making Greater Flexibility Conclusion LangGraph Key Takeaways: Use AI for Routine Tasks Make Decisions with Data Encourage Collaboration Stay Flexible GitHub Repository: GitHub - yotambraun/Project_Management_System_with_RAG Thanks for reading If you enjoyed this post follow Medium LinkedIn References LangGraph LangChain ChatGroq langchain_ollama ollama groq Rags NLP Langchain Langgraph Agents 3 Follow 29 Followers · Writer for TDoawtaa rSdcsi eAnItist specializing in time series forecasting | Master's in Statistics